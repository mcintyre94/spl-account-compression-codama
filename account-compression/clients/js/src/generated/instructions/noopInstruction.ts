/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  transformEncoder,
  type AccountMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from '@solana/kit';
import { SPL_NOOP_PROGRAM_ADDRESS } from '../programs';

export const NOOP_INSTRUCTION_DISCRIMINATOR = new Uint8Array([0]);

export function getNoopInstructionDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 1).encode(
    NOOP_INSTRUCTION_DISCRIMINATOR
  );
}

export type NoopInstructionInstruction<
  TProgram extends string = typeof SPL_NOOP_PROGRAM_ADDRESS,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<TRemainingAccounts>;

export type NoopInstructionInstructionData = {
  discriminator: ReadonlyUint8Array;
  data: ReadonlyUint8Array;
};

export type NoopInstructionInstructionDataArgs = { data: ReadonlyUint8Array };

export function getNoopInstructionInstructionDataEncoder(): Encoder<NoopInstructionInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 1)],
      ['data', addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ]),
    (value) => ({ ...value, discriminator: NOOP_INSTRUCTION_DISCRIMINATOR })
  );
}

export function getNoopInstructionInstructionDataDecoder(): Decoder<NoopInstructionInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 1)],
    ['data', addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
  ]);
}

export function getNoopInstructionInstructionDataCodec(): Codec<
  NoopInstructionInstructionDataArgs,
  NoopInstructionInstructionData
> {
  return combineCodec(
    getNoopInstructionInstructionDataEncoder(),
    getNoopInstructionInstructionDataDecoder()
  );
}

export type NoopInstructionInput = {
  data: NoopInstructionInstructionDataArgs['data'];
};

export function getNoopInstructionInstruction<
  TProgramAddress extends Address = typeof SPL_NOOP_PROGRAM_ADDRESS,
>(
  input: NoopInstructionInput,
  config?: { programAddress?: TProgramAddress }
): NoopInstructionInstruction<TProgramAddress> {
  // Program address.
  const programAddress = config?.programAddress ?? SPL_NOOP_PROGRAM_ADDRESS;

  // Original args.
  const args = { ...input };

  const instruction = {
    programAddress,
    data: getNoopInstructionInstructionDataEncoder().encode(
      args as NoopInstructionInstructionDataArgs
    ),
  } as NoopInstructionInstruction<TProgramAddress>;

  return instruction;
}

export type ParsedNoopInstructionInstruction<
  TProgram extends string = typeof SPL_NOOP_PROGRAM_ADDRESS,
> = {
  programAddress: Address<TProgram>;
  data: NoopInstructionInstructionData;
};

export function parseNoopInstructionInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>
): ParsedNoopInstructionInstruction<TProgram> {
  return {
    programAddress: instruction.programAddress,
    data: getNoopInstructionInstructionDataDecoder().decode(instruction.data),
  };
}
